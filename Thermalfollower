   #include <opencv2/core/core.hpp>
   #include <opencv2/highgui/highgui.hpp>
   #include <opencv2/imgproc/imgproc.hpp>
   #include <iostream>
   #include <opencv2/imgproc/imgproc.hpp>
   #include <sstream>
   #include "ros/ros.h"
   #include "geometry_msgs/Twist.h"
   #include "geometry_msgs/Pose.h"

    using namespace cv;
    using namespace std;

    int counter;

void publish(int moveType){

  ros::NodeHandle n; // Initiatialize the publisher node

  ros::Publisher cmd_vel = n.advertise<geometry_msgs::Twist>("/mobile_base/commands/velocity", 1); //Publish to this topic

  ros::Rate loop_rate(30); // The rate of the loop (currently 1 msg per second)


  geometry_msgs::Twist input_vel; //Type of the topic which is being published


if(counter == 90){
      if (moveType == 1){

          input_vel.linear.x=0.5;
          input_vel.linear.y=0.0;
          input_vel.linear.z=0.0;


          input_vel.angular.x=0.0;
          input_vel.angular.y=0.0;
          input_vel.angular.z=0.0;

          cmd_vel.publish(input_vel);

          counter = 0;
          return;
}
}

if (counter == 90){
      if (moveType == 2){
          input_vel.linear.x=1.0;
          input_vel.linear.y=0.0;
          input_vel.linear.z=0.0;


          input_vel.angular.x=0.0;
          input_vel.angular.y=0.0;
          input_vel.angular.z=0.0;

          cmd_vel.publish(input_vel);
          counter = 0;
          return;
}
}

if (counter == 90){
      if (moveType == 3){
          input_vel.linear.x=-1.0;
          input_vel.linear.y=0.0;
          input_vel.linear.z=0.0;



          input_vel.angular.x=0.0;
          input_vel.angular.y=0.0;
          input_vel.angular.z=-1.0;

          cmd_vel.publish(input_vel);
          counter = 0;
          return;
}
}

if(counter == 90){
      if (moveType == 4){
          input_vel.linear.x=1.0;
          input_vel.linear.y=0.0;
          input_vel.linear.z=0.0;



          input_vel.angular.x=0.0;
          input_vel.angular.y=0.0;
          input_vel.angular.z=1.0;

          cmd_vel.publish(input_vel);
          counter = 0;
          return;
}
}

  ros::spinOnce();

  loop_rate.sleep();


  return;
}




int main(int argc, char* argv[])
{

    ros::init(argc, argv, "Publisher"); //Initiatialize ROS

    VideoCapture cap;

    cap.open ("http://root:axis@10.42.0.69/axis-cgi/mjpg/video.cgi?resolution=640x480&req_fps=30&.mjpg");

        if (!cap.isOpened())  // if not success, exit program
    {
        cout << "Cannot open the video cam" << endl;
        return -1;
    }

   double dWidth = cap.get(CV_CAP_PROP_FRAME_WIDTH); //get the width of frames of the video
   double dHeight = cap.get(CV_CAP_PROP_FRAME_HEIGHT); //get the height of frames of the video

    cout << "Frame size : " << dWidth << " x " << dHeight << endl;

    namedWindow("ThermalLiveFeed",CV_WINDOW_AUTOSIZE); //create a window called "MyVideo"
    namedWindow("ThresholdLiveFeed",CV_WINDOW_AUTOSIZE);

    while (1)
    {

        Mat frame;

        double thresh = 76;
        double maxVal = 255;

        bool bSuccess = cap.read(frame); // read a new frame from video

         if (!bSuccess) //if not success, break loop
        {
             cout << "Cannot read a frame from video stream" << endl;
             break;
        }


        Mat grey;
        Mat dst;

        cv::cvtColor(frame, grey, CV_BGR2GRAY);


        imshow("ThermalLiveFeed", frame); //show the frame in "MyVideo" window

        threshold(grey, dst, thresh, maxVal, THRESH_BINARY);

        imshow("ThresholdLiveFeed", dst);


            std::vector<std::vector<cv::Point> > contours;
            Mat imageClone;
            imageClone = dst.clone();
            findContours(imageClone, contours, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);

            Mat drawImg(dst.size(), CV_8UC3, Scalar(0,0,0));

        for(size_t idx = 0; idx < contours.size(); idx++){
            int area = contourArea(contours[idx]);
          //  cout << idx << " area:" << area << endl;

        if(area > 500){

            drawContours(drawImg, contours, idx, Scalar(0,0,255));
            Moments mu = moments(contours[idx], false);
            Point2f mc = Point2f(mu.m10/mu.m00, mu.m01/mu.m00);
            cout << "Coordinates: " << mc.x << ", " << mc.y << endl;
            circle(drawImg, mc, 5,Scalar(0,255,0));


            namedWindow("findContours", WINDOW_AUTOSIZE);

            imshow("findContours", drawImg);


        if(100 > mc.x){


          cout << "He is hitting the border on the left x-axis: " << mc.x << endl;

          publish(1); // Left x-axis is "drive right" angular and linear

      }

      if (mc.x > 540){


         cout << "He is hitting the border on the right x-axis: " << mc.x << endl;

         publish(2); // Right x-axis is "drive left" angular and linear
      }

      if ( 100 > mc.y){

          cout << "He is hitting the border on the upper y-axis: " << mc.y << endl;

          publish(3); // Upper y-axis is "drive backwards" MinusLinear

      }

      if (mc.y > 380){

          cout << "He is hitting the border on the lower y-axis: " << mc.y << endl;

          publish(4); // Lower y-axis is "drive forwards" Linear

      }

      counter++;
    }
  }

        if (waitKey(30) == 27) //wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop
       {
            cout << "esc key is pressed by user" << endl;
            break;
       }
}
    return 0;
}
